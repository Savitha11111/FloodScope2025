"""Preprocessing for Copernicus EMS flood mapping products."""
from __future__ import annotations

import argparse
import csv
import json
import pathlib
from typing import Iterable

try:
    import fiona
except ImportError as exc:
    raise ImportError("The fiona package is required for Copernicus EMS preprocessing. Install with `pip install fiona`." ) from exc
import rasterio
from rasterio.enums import Resampling
from rasterio.features import rasterize
from rasterio.warp import calculate_default_transform, reproject

from datasets.download_utils import record_license

LICENSE_TEXT = "Copernicus EMS derived products generated by FloodScope2025."


def _ensure_dirs(root: pathlib.Path) -> tuple[pathlib.Path, pathlib.Path]:
    processed = root / "processed"
    metadata_dir = root / "metadata"
    processed.mkdir(parents=True, exist_ok=True)
    metadata_dir.mkdir(parents=True, exist_ok=True)
    return processed, metadata_dir


def _harmonise_raster(src_path: pathlib.Path, dst_path: pathlib.Path, dst_crs: str = "EPSG:4326") -> None:
    with rasterio.open(src_path) as src:
        transform, width, height = calculate_default_transform(src.crs, dst_crs, src.width, src.height, *src.bounds)
        kwargs = src.meta.copy()
        kwargs.update({"crs": dst_crs, "transform": transform, "width": width, "height": height})
        with rasterio.open(dst_path, "w", **kwargs) as dst:
            for band_index in range(1, src.count + 1):
                reproject(
                    source=rasterio.band(src, band_index),
                    destination=rasterio.band(dst, band_index),
                    src_transform=src.transform,
                    src_crs=src.crs,
                    dst_transform=transform,
                    dst_crs=dst_crs,
                    resampling=Resampling.bilinear if src.count > 1 else Resampling.nearest,
                )


def _rasterise_vector(vector_path: pathlib.Path, reference: pathlib.Path, destination: pathlib.Path) -> None:
    with rasterio.open(reference) as ref:
        meta = ref.meta.copy()
        meta.update({"count": 1, "dtype": "uint8"})
        with rasterio.open(destination, "w", **meta) as dst:
            with fiona.open(vector_path) as src:
                geometries = [(feature["geometry"], 1) for feature in src]
            mask = rasterize(geometries, out_shape=(ref.height, ref.width), transform=ref.transform, fill=0, dtype="uint8")
            dst.write(mask, 1)


def _write_metadata(metadata_dir: pathlib.Path, records: Iterable[dict]) -> None:
    metadata_path = metadata_dir / "copernicus_events.csv"
    fieldnames = ["event_id", "image_path", "flood_mask_path"]
    with metadata_path.open("w", newline="", encoding="utf-8") as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for record in records:
            writer.writerow(record)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Preprocess Copernicus EMS flood maps")
    parser.add_argument("--output-root", type=pathlib.Path, required=True)
    parser.add_argument("--interim-root", type=pathlib.Path, default=None)
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    interim_root = args.interim_root or args.output_root / "interim"
    processed_root, metadata_dir = _ensure_dirs(args.output_root)

    records = []
    for event_dir in sorted(interim_root.glob("*")):
        if not event_dir.is_dir():
            continue
        event_id = event_dir.name
        image_candidates = list(event_dir.rglob("*observed*.tif")) or list(event_dir.rglob("*.tif"))
        vector_candidates = list(event_dir.rglob("*flood*.shp"))
        if not image_candidates or not vector_candidates:
            continue
        image_path = image_candidates[0]
        vector_path = vector_candidates[0]

        event_processed = processed_root / event_id
        event_processed.mkdir(parents=True, exist_ok=True)
        harmonised_image = event_processed / "image.tif"
        harmonised_mask = event_processed / "flood_mask.tif"
        _harmonise_raster(image_path, harmonised_image)
        _rasterise_vector(vector_path, harmonised_image, harmonised_mask)

        records.append({
            "event_id": event_id,
            "image_path": str(harmonised_image),
            "flood_mask_path": str(harmonised_mask),
        })

    _write_metadata(metadata_dir, records)
    summary = {
        "num_events": len(records),
    }
    with (metadata_dir / "copernicus_summary.json").open("w", encoding="utf-8") as fh:
        json.dump(summary, fh, indent=2)

    record_license(args.output_root, LICENSE_TEXT)
    print(f"Processed {len(records)} Copernicus EMS events into {processed_root}.")


if __name__ == "__main__":
    main()
